[
  {
    "objectID": "posts/dolar/index.html",
    "href": "posts/dolar/index.html",
    "title": "API dos correios",
    "section": "",
    "text": "Neste post, vamos explorar um script em Python criado para consultar a cotação diária do dólar (PTAX) diretamente da API do Banco Central do Brasil e gerar automaticamente um gráfico interativo para qualquer mês desejado.\nBibliotecas utilizadas\nimport pandas as pd\nimport requests\nimport plotly.express as px\nimport calendar\nfrom datetime import datetime\nimport os\nO usuário informa o período no formato MMYYYY (por exemplo, “042017”). O código converte essa string em uma data válida com datetime.strptime()\nEssas datas são então formatadas no padrão MM-DD-YYYY, conforme exigido pela API do Banco Central.\ndef gerar_grafico_dolar(periodo_mmyyyy):\n    try:\n        first_date = datetime.strptime(periodo_mmyyyy, \"%m%Y\")\n    except ValueError:\n        print(\"Formato inválido.\")\n        return\n\n    last_day = calendar.monthrange(first_date.year, first_date.month)[1]\n    last_date = first_date.replace(day=last_day)\n    \n    start_str = first_date.strftime(\"%m-%d-%Y\")\n    end_str = last_date.strftime(\"%m-%d-%Y\")\n\nProcessamento dos dados com Pandas\n    \n    base_url = \"https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)\"\n    url = f\"{base_url}?@dataInicial='{start_str}'&@dataFinalCotacao='{end_str}'&$top=1000&$format=json\"\n    \n    \n    response = requests.get(url)\n    data_json = response.json()\n    \n    if not data_json['value']:\n        print(\"Nenhum dado retornado pela API.\")\n        return\n\n    df = pd.DataFrame(data_json['value'])\n    df = df[['dataHoraCotacao', 'cotacaoVenda']]\n    df['dataHoraCotacao'] = pd.to_datetime(df['dataHoraCotacao']).dt.normalize()\n    df = df.set_index('dataHoraCotacao')\n\n    idx_completo = pd.date_range(start=first_date, end=last_date)\n    df = df.reindex(idx_completo)\n\n    df['cotacaoVenda'] = df['cotacaoVenda'].ffill()\n    df['cotacaoVenda'] = df['cotacaoVenda'].bfill()\nGeração do gráfico interativo com Plotly\nif not data_json['value']:\n        print(\"Nenhum dado retornado pela API.\")\n        return\n\n    df = pd.DataFrame(data_json['value'])\n    df = df[['dataHoraCotacao', 'cotacaoVenda']]\n    df['dataHoraCotacao'] = pd.to_datetime(df['dataHoraCotacao']).dt.normalize()\n    df = df.set_index('dataHoraCotacao')\n\n    idx_completo = pd.date_range(start=first_date, end=last_date)\n    df = df.reindex(idx_completo)\n\n    df['cotacaoVenda'] = df['cotacaoVenda'].ffill()\n    df['cotacaoVenda'] = df['cotacaoVenda'].bfill()\n\n    df = df.reset_index()\n    df.columns = ['Data', 'Cotação (R$)']\n\n    fig = px.line(\n        df,\n        x='Data',\n        y='Cotação (R$)',\n        title=f'Cotação do Dólar (Venda) - {first_date.strftime(\"%m/%Y\")}',\n        markers=True\n    )\n    \nPor fim a geração de imagem e site\n    \n    nome_arquivo = f\"grafico_dolar_{periodo_mmyyyy}.html\"\n    fig.write_html(nome_arquivo)\n\n    try:\n        os.startfile(nome_arquivo)\n    except:\n        pass\n\ngerar_grafico_dolar(\"042017\")\nCódigo completo\n\nimport pandas as pd\nimport requests\nimport plotly.express as px\nimport calendar\nfrom datetime import datetime\nimport os\n\ndef gerar_grafico_dolar(periodo_mmyyyy):\n    try:\n        first_date = datetime.strptime(periodo_mmyyyy, \"%m%Y\")\n    except ValueError:\n        print(\"Formato inválido.\")\n        return\n\n    last_day = calendar.monthrange(first_date.year, first_date.month)[1]\n    last_date = first_date.replace(day=last_day)\n    \n    start_str = first_date.strftime(\"%m-%d-%Y\")\n    end_str = last_date.strftime(\"%m-%d-%Y\")\n\n    base_url = \"https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)\"\n    url = f\"{base_url}?@dataInicial='{start_str}'&@dataFinalCotacao='{end_str}'&$top=1000&$format=json\"\n    \n    response = requests.get(url)\n    data_json = response.json()\n    \n    if not data_json['value']:\n        print(\"Nenhum dado retornado pela API.\")\n        return\n\n    df = pd.DataFrame(data_json['value'])\n    df = df[['dataHoraCotacao', 'cotacaoVenda']]\n    df['dataHoraCotacao'] = pd.to_datetime(df['dataHoraCotacao']).dt.normalize()\n    df = df.set_index('dataHoraCotacao')\n\n    idx_completo = pd.date_range(start=first_date, end=last_date)\n    df = df.reindex(idx_completo)\n\n    df['cotacaoVenda'] = df['cotacaoVenda'].ffill()\n    df['cotacaoVenda'] = df['cotacaoVenda'].bfill()\n\n    df = df.reset_index()\n    df.columns = ['Data', 'Cotação (R$)']\n\n    fig = px.line(\n        df,\n        x='Data',\n        y='Cotação (R$)',\n        title=f'Cotação do Dólar (Venda) - {first_date.strftime(\"%m/%Y\")}',\n        markers=True\n    )\n    \n    nome_arquivo = f\"grafico_dolar_{periodo_mmyyyy}.html\"\n    fig.write_html(nome_arquivo)\n\n    try:\n        os.startfile(nome_arquivo)\n    except:\n        pass\n\ngerar_grafico_dolar(\"042017\")\n\n\n\n\nresultado"
  },
  {
    "objectID": "posts/welcome copy/index.html",
    "href": "posts/welcome copy/index.html",
    "title": "Regressão linear",
    "section": "",
    "text": "Este script implementa, do zero, um processo completo de Regressão Linear Simples usando apenas operações matriciais e a biblioteca plotnine para visualização. Ele lê valores de X e Y a partir de arquivos .txt, calcula a reta que melhor se ajusta aos dados e gera automaticamente um gráfico em PNG, abrindo-o no navegador.\n\nPrimeiramente começaremos com os imports\nimport numpy as np\nimport pandas as pd\nfrom plotnine import ggplot, aes, geom_point, geom_smooth, geom_abline, ggsave, theme_light, labs\nimport webbrowser\nimport os\nLeitura dos Dados de Entrada\nO programa começa carregando os valores de X e Y a partir de dois arquivos de texto\nwith open(r\"X.txt\", \"r\") as f:\n    valores_x = [float(linha.strip()) for linha in f if linha.strip()]\n\nwith open(r\"y.txt\", \"r\") as f:\n    valores_y = [float(linha.strip()) for linha in f if linha.strip()]\n\nif len(valores_x) != len(valores_y):\n    raise ValueError(f\"Os arquivos têm tamanhos diferentes: X={len(valores_x)}, y={len(valores_y)}\")\n\nY = np.array(valores_y)\n\n\nX_matriz = np.column_stack((np.ones(len(valores_x)), valores_x))\nRegressão Linear pelo Método Matricial\nDiferente de usar bibliotecas prontas como sklearn, aqui a regressão é feita usando a fórmula clássica\nX_T = X_matriz.T                     \nXT_X = X_T @ X_matriz               \nXT_X_inv = np.linalg.inv(XT_X)       \nXT_y = X_T @ Y                      \n\n\nbeta = XT_X_inv @ XT_y\n\n\nintercepto_a = beta[0]\ninclinacao_b = beta[1]\nConstrução do Gráfico com plotnine\ndf = pd.DataFrame({\"x\": valores_x, \"y\": valores_y})\n\n\nplot = (\n  ggplot(df, aes(\"x\", \"y\"))\n  + geom_point(color=\"black\", alpha=0.5) \n  + geom_abline(intercept=intercepto_a, slope=inclinacao_b, color=\"blue\", size=1.5) \n  + labs(x=\"x\", y=\"y\")\n  + theme_light()\n)\nE por fim, gera o grafico\nplot.save(\"grafico.png\") \n\nprint(\"Abrindo o gráfico no navegador...\")\ncaminho_arquivo = os.path.abspath(\"grafico.png\")\nwebbrowser.open(r\"C:\\Users\\eduar\\Downloads\\Documents\\Scripts\\grafico.png\")\nCódigo completo!\n\nimport numpy as np\nimport pandas as pd\nfrom plotnine import ggplot, aes, geom_point, geom_smooth, geom_abline, ggsave, theme_light, labs\nimport webbrowser\nimport os\n\nwith open(r\"C:\\Users\\eduar\\Downloads\\Documents\\Scripts\\atividades\\X.txt\", \"r\") as f:\n    valores_x = [float(linha.strip()) for linha in f if linha.strip()]\n\nwith open(r\"C:\\Users\\eduar\\Downloads\\Documents\\Scripts\\atividades\\y.txt\", \"r\") as f:\n    valores_y = [float(linha.strip()) for linha in f if linha.strip()]\n\nif len(valores_x) != len(valores_y):\n    raise ValueError(f\"Os arquivos têm tamanhos diferentes: X={len(valores_x)}, y={len(valores_y)}\")\n\nY = np.array(valores_y)\n\n\nX_matriz = np.column_stack((np.ones(len(valores_x)), valores_x))\n\n\nX_T = X_matriz.T                     \nXT_X = X_T @ X_matriz               \nXT_X_inv = np.linalg.inv(XT_X)       \nXT_y = X_T @ Y                      \n\n\nbeta = XT_X_inv @ XT_y\n\n\nintercepto_a = beta[0]\ninclinacao_b = beta[1]\n\nprint(f\"Cálculo Concluído!\")\nprint(f\"Intercepto (a): {intercepto_a}\")\nprint(f\"Inclinação (b): {inclinacao_b}\")\nprint(f\"Equação da reta: y = {intercepto_a:.4f} + {inclinacao_b:.4f}x\")\n\n\ndf = pd.DataFrame({\"x\": valores_x, \"y\": valores_y})\n\n\nplot = (\n  ggplot(df, aes(\"x\", \"y\"))\n  + geom_point(color=\"black\", alpha=0.5) \n  + geom_abline(intercept=intercepto_a, slope=inclinacao_b, color=\"blue\", size=1.5) \n  + labs(x=\"x\", y=\"y\")\n  + theme_light()\n)\nplot.save(\"grafico.png\") \n\nprint(\"Abrindo o gráfico no navegador...\")\ncaminho_arquivo = os.path.abspath(\"grafico.png\")\nwebbrowser.open(r\"C:\\Users\\eduar\\Downloads\\Documents\\Scripts\\grafico.png\")"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Sobre Mim",
    "section": "",
    "text": "Jovem de 18 anos, cursando Engenharia da Computação, com experiência administrativa, domínio intermediário de ferramentas digitais"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog do Eduardo",
    "section": "",
    "text": "API Cotação\n\n\n\nAPI\n\nCode\n\nPython\n\nCotação\n\n\n\n\n\n\n\n\n\nNov 23, 2025\n\n\nEduardo Nicolau Martins\n\n\n\n\n\n\n\n\n\n\n\n\nRegressão linear\n\n\n\nMatemática\n\nLogica\n\nPython\n\n\n\n\n\n\n\n\n\nNov 20, 2025\n\n\nEduardo Nicolau Martins\n\n\n\n\n\n\n\n\n\n\n\n\nMonitoramento da frota de ônibus\n\n\n\nAPI\n\nMonitoramento\n\nÔnibus\n\nPython\n\n\n\n\n\n\n\n\n\nNov 20, 2025\n\n\nEduardo Nicolau Martins\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Monitoramento da frota de ônibus",
    "section": "",
    "text": "Neste post, vamos visualizar as paradas e a posição em tempo real dos ônibus da linha 8200-10 (Terminal Lapa - Terminal Pirituba) utilizando a API Olho Vivo da SPTrans e a biblioteca Folium.\nOs pins azuis representam as paradas oficiais da linha, e os ícones vermelhos de ônibus representam a localização exata dos veículos no momento em que este código foi executado.\n\nimport requests\nimport folium\nfrom IPython.display import display\n\nTOKEN = \"edc09af1758e3c9c2f062f80f3131da78d17ad4651f071c2b68ab7b426fe26d6\"\nLINHA_DESEJADA = \"8200-10\"\n\nBASE_URL = \"http://api.olhovivo.sptrans.com.br/v2.1\"\nsession = requests.Session()\n\ndef autenticar():\n    response = session.post(f\"{BASE_URL}/Login/Autenticar?token={TOKEN}\")\n    return response.text == \"true\"\n\ndef obter_dados_inteligente(termo):\n    response = session.get(f\"{BASE_URL}/Linha/Buscar?termosBusca={termo}\")\n    linhas = response.json()\n    if not linhas:\n        return [], None\n    for info in linhas:\n        codigo = info['cl']\n        resp_paradas = session.get(f\"{BASE_URL}/Parada/BuscarParadasPorLinha?codigoLinha={codigo}\")\n        lista_paradas = resp_paradas.json()\n        if len(lista_paradas) &gt; 0:\n            return lista_paradas, codigo\n    return [], None\n\ndef obter_posicoes(codigo_linha):\n    if codigo_linha is None:\n        return []\n    response = session.get(f\"{BASE_URL}/Posicao/Linha?codigoLinha={codigo_linha}\")\n    dados = response.json()\n    return dados['vs']\n\n\nif autenticar():\n    print(\"Autenticado! Buscando dados...\")\n    paradas, codigo_linha = obter_dados_inteligente(LINHA_DESEJADA)\n    \n    if codigo_linha:\n        onibus_agora = obter_posicoes(codigo_linha)\n    else:\n        onibus_agora = []\n        \n    print(f\"Resumo: {len(paradas)} paradas e {len(onibus_agora)} ônibus.\")\n    \n\n    lat_mapa, lon_mapa = -23.5505, -46.6333\n    if len(paradas) &gt; 0:\n        lat_mapa, lon_mapa = paradas[0]['py'], paradas[0]['px']\n    elif len(onibus_agora) &gt; 0:\n        lat_mapa, lon_mapa = onibus_agora[0]['py'], onibus_agora[0]['px']\n    \n\n    mapa = folium.Map(location=[lat_mapa, lon_mapa], zoom_start=13)\n    \n    for p in paradas:\n        folium.Marker(\n            [p['py'], p['px']],\n            popup=f\"Parada: {p['np']}\",\n            icon=folium.Icon(color=\"blue\", icon=\"info-sign\")\n        ).add_to(mapa)\n        \n    for bus in onibus_agora:\n        folium.Marker(\n            [bus['py'], bus['px']],\n            popup=f\"Prefixo: {bus['p']}\",\n            icon=folium.Icon(color=\"red\", icon=\"bus\", prefix=\"fa\")\n        ).add_to(mapa)\n    \n    display(mapa)\n\nelse:\n    print(\"Erro na autenticação. Verifique o Token.\")\n\nAutenticado! Buscando dados...\nResumo: 5 paradas e 1 ônibus.\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook"
  }
]